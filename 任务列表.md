1. 克隆指定git目录
<prompt>
 <extra_info>额外信息：
 - 目标平台：macOS / Linux 优先，Windows 能支持则更好，但不是强制。
 - 本机已安装 git，可通过命令行调用。
 - 使用 Rust 2021 edition，推荐通过 `cargo` 构建一个小型 CLI 工具。
 - 要抓取的通常是 GitHub 公共仓库（例如 `modelcontextprotocol/rust-sdk`），后续有可能扩展到私有仓库（可预留 token 参数，但当前不是硬性要求）。
 </extra_info>


背景：
现在我需要一个「抓取 GitHub 仓库指定子目录到本地」的工具。
需求特征：
	1.	不想在当前项目目录下直接 git clone，避免污染当前项目的 .git 结构。
	2.	希望脚本自动完成：在临时目录中完成仓库克隆/下载，再把指定子目录拷贝到当前项目或目标目录，最后清理临时文件。
	3.	GitHub 已经关闭了对 SVN 的支持，无法再使用 svn export https://github.com/.../trunk/... 这种方式抓取子目录。
	4.	当前手动流程大致是：
	•	在临时目录执行 git clone 或 sparse-checkout 只拉取需要的路径；
	•	复制目标子目录到当前项目中的某个目录；
	•	删除临时仓库目录。
我希望把这套流程抽象成一个 Rust CLI 工具，之后只用一条命令就能完成指定仓库子目录的抓取。

 </background>


<main_goal>主要目标：
使用 Rust 实现一个命令行工具，从 GitHub 仓库中下载指定分支下的某个子目录，并将该子目录拷贝到本地指定路径，同时确保不影响调用目录自身的 git 仓库结构（即不在当前项目目录中新建 .git 等信息）。
</main_goal>

步骤：
	1.	设计整体技术方案：
	•	可以选择：
a) 借助系统已安装的 git 命令，在临时目录执行 git clone / sparse-checkout；
b) 或者使用 HTTP 调用 GitHub API / 原始文件 URL 递归下载指定路径。
	•	先选定一个实现路径（推荐优先使用系统 git + 临时目录，逻辑清晰）。
	2.	设计 CLI 接口：
	•	例如使用 clap 或 structopt 等库，定义参数：
	•	--repo：仓库标识，如 modelcontextprotocol/rust-sdk 或完整 URL；
	•	--branch：分支名，默认 main；
	•	--path：仓库内的子目录路径，如 examples/servers；
	•	--dest：本地目标路径，如 ./example-servers；
	•	可选 --token：预留 GitHub 访问 token，用于未来支持私有仓库。
	3.	实现核心逻辑：
	•	创建系统临时目录（例如使用 tempfile），在该临时目录中执行所有 git 相关操作；
	•	在临时目录中：
	•	使用合适的 git 命令，仅获取目标子目录（可用 --depth=1 + sparse-checkout 优化）；
	•	检出指定分支；
	•	确保目标子目录存在；
	•	将该子目录拷贝到用户指定的 --dest 路径：
	•	如果 --dest 已存在，需定义行为（覆盖 / 合并 / 提示错误），并在代码中明确实现；
	•	保证复制结果仅包含文件和普通目录，不携带上游仓库的 .git。
	•	结束时清理临时目录。
	4.	增加错误处理与日志输出：
	•	对网络失败、仓库不存在、分支不存在、目标路径不存在等情况进行友好报错；
	•	对关键步骤增加简单日志输出（如：正在克隆、正在复制、完成等）。
	5.	提供使用说明和示例：
	•	在 README 或注释中说明如何安装与调用；
	•	给出若干实际使用示例命令。

 </steps>


输入：
通过命令行参数传入以下信息：
	•	--repo / -r（必填）：GitHub 仓库标识，支持两种形式：
	1.	简写：owner/repo，例如 modelcontextprotocol/rust-sdk
	2.	完整 URL：https://github.com/modelcontextprotocol/rust-sdk.git
	•	--branch / -b（可选）：分支名，默认为 main 或 master（需在实现中有合理默认和 fallback）。
	•	--path / -p（必填）：仓库内部的子目录路径，例如：examples/servers。
	•	--dest / -d（必填）：本地目标目录路径，例如：./example-servers。
	•	--token（可选）：GitHub 访问 token，用于后续扩展到私有仓库（当前可以先不实现鉴权逻辑，只预留参数接口）。

 </input>


输出：
	1.	一个可编译运行的 Rust CLI 工具（cargo 项目结构），核心包括：
	•	Cargo.toml：包含依赖（如 clap / anyhow / tempfile 等）。
	•	src/main.rs：实现命令行参数解析与主逻辑。
	•	如有需要，可以抽取若干模块放在 src/ 其他文件中。
	2.	运行该工具后，在本地 --dest 路径生成/更新对应的目录结构，内容与远程仓库对应子目录一致（不包含 .git 等版本控制信息）。
	3.	在命令行输出执行过程中的关键信息和错误提示，便于用户理解执行进度与失败原因。

 </output>


功能要求：
	1.	必须确保：
	•	不在当前目录写入 .git，不破坏当前项目的 Git 仓库结构；
	•	所有与 git 仓库相关的操作只发生在临时目录。
	2.	对公共 GitHub 仓库应能正常工作，支持 HTTP / HTTPS 访问。
	3.	对输入参数进行基本校验：
	•	--repo、--path、--dest 缺失时要给出清晰的错误信息；
	•	对无法访问的仓库、错误的分支名、错误的子目录路径，要有明确的错误提示。
	4.	工具应尽可能具备可扩展性：
	•	将来可以替换实现方式为 GitHub API + HTTP 下载，而不需要大规模重写；
	•	保留 --token 参数，为后续支持私有仓库预留接口。
	5.	错误处理：
	•	使用合适的错误处理库（如 anyhow 或 thiserror）；
	•	在错误信息中包含关键上下文，便于排查问题。
	6.	代码风格：
	•	遵循 Rust 常规代码风格，合理拆分函数，避免巨型函数；
	•	对关键逻辑添加必要的注释（不是流水账式注释，而是解释设计意图）。

 </requirements>


验收标准：
	1.	能够成功编译并运行（例如 cargo build / cargo run 正常）。
	2.	在网络正常、仓库存在的情况下，执行类似命令：
	•	my-tool --repo modelcontextprotocol/rust-sdk --branch main --path examples/servers --dest ./example-servers
能够在当前目录产生 ./example-servers，其内容与 GitHub 仓库 examples/servers 一致，且：
	•	./example-servers 内部不包含 .git；
	•	当前项目目录下原有的 .git 不被修改。
	3.	对明显错误的输入（错误仓库名、错误分支、错误路径）能输出可读性强的错误信息，并以非 0 退出码结束。
	4.	临时目录在任务成功或失败后都能被正确清理，不留下无用数据。
	5.	代码结构清晰，有清晰的 main 入口和核心逻辑抽象，便于后续维护和扩展。

 </acceptance>


边界条件：
	1.	优先考虑 GitHub 公共仓库场景，私有仓库支持可暂时不实现。
	2.	假设用户本地已经安装 git，工具可以依赖调用系统 git 命令，而不必须使用 git2 crate 实现纯 Rust Git 客户端。
	3.	网络异常、GitHub 访问受限时，工具只需给出清晰错误提示，无需实现复杂的重试机制。
	4.	不强制要求跨平台完美一致，但至少应在类 Unix 系统（macOS / Linux）上有清晰可行的实现。
	5.	不需要实现交互式界面，全部通过命令行参数控制。

 </constraints>


例子：
1）典型使用场景：
命令：
my-tool 
–repo modelcontextprotocol/rust-sdk 
–branch main 
–path examples/servers 
–dest ./example-servers

预期行为：
	•	在系统临时目录中新建一个临时文件夹；
	•	在临时目录中克隆 https://github.com/modelcontextprotocol/rust-sdk.git（可采用 --depth=1、或 sparse-checkout 仅获取 examples/servers）；
	•	检出 main 分支；
	•	将临时目录中的 examples/servers 拷贝到当前工作目录下的 ./example-servers；
	•	若 ./example-servers 不存在，则新建；若存在，按约定方式覆盖或报错（由代码逻辑确定并在文档中说明）；
	•	删除临时目录；
	•	最终在当前项目中看到一个普通的 example-servers 文件夹，不包含任何上游 Git 仓库的元数据。

2）错误示例：
命令：
my-tool 
–repo modelcontextprotocol/rust-sdk 
–branch main 
–path examples/not-exist 
–dest ./example-servers

预期行为：
	•	程序在检测远程仓库结构时发现 examples/not-exist 不存在；
	•	输出类似「远程仓库中未找到指定子目录 examples/not-exist」的错误信息；
	•	退出码为非 0；
	•	不在当前目录产生任何半成品输出（或在出错时自动清理已创建的目标目录）。

 </examples>
</prompt>

2. 增强功能，简化输入参数，从输入的github url中自动提取repo和path（branch未指定时默认主分支），尽可能少的让用户输入参数
<prompt>
 <extra_info>额外信息：</extra_info>
 <background>背景：</background>
 <main_goal>主要目标：增强功能，简化输入参数，从输入的github url中自动提取repo和path（branch未指定时默认主分支），尽可能少的让用户输入参数</main_goal>
 <steps>步骤：</steps>
 <input>输入：</input>
 <output>输出：</output>
 <requirements>功能要求：</requirements>
 <acceptance>验收标准：</acceptance>
 <constraints>边界条件：无法正常识别url中的参数的时候，报错，并退出</constraints>
 <examples>例子：https://github.com/modelcontextprotocol/rust-sdk/tree/main/examples/servers
 提取出repo是modelcontextprotocol/rust-sdk
 路径是/examples/servers
 </examples>
</prompt>

3. 在gitignore中自动增加指定的例子目录
<prompt>
 <extra_info>额外信息：</extra_info>
 <background>背景：</background>
 <main_goal>主要目标：</main_goal>
 <steps>步骤：</steps>
 <input>输入：</input>
 <output>输出：</output>
 <requirements>功能要求：
 1. 如果脚本在执行的时候为gitignore文件添加了内容，需要在日志中输出出来</requirements>
 <acceptance>验收标准：</acceptance>
 <constraints>边界条件：
 1. 查看脚本执行目录的.gitignore文件进行添加，如果不存在.gitignore文件，则不添加</constraints>
 <examples>例子：
 执行git-get https://github.com/modelcontextprotocol/rust-sdk/tree/main/examples/servers -d ./example
 自动把本地目录./example加入到.gitignore文件中，默认加到文件最后，而且在。gitignore文件中备注此条目由git-get程序自动添加
 </examples>
</prompt>

4. 安全性增强
<prompt>
 <extra_info>额外信息：</extra_info>
 <background>背景：</background>
 <main_goal>主要目标：使用-d指定本地目录时，只有在指定目录为空或者不存在时才能把抓取的文件写入，其他情况直接报错，避免写入文件覆盖已有文件，造成数据损失</main_goal>
 <steps>步骤：</steps>
 <input>输入：</input>
 <output>输出：</output>
 <requirements>功能要求：</requirements>
 <acceptance>验收标准：</acceptance>
 <constraints>边界条件：</constraints>
 <examples>例子：</examples>
</prompt>
